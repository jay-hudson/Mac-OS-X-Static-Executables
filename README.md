# Mac-OS-X-Static-Executables
It has often been said that it is impossible to create user space executables that are linked statically.  The small examples provided show that this is not true.  They are written in 64 bit assembly language. Their only task is to print a message to the console.  This is accomplished by directly invoking a system call, known as a syscall, directly to the kernel.

In a more complicated fashion, this is what all executables do in the end.  What makes Mac OS X more complicated is that there are multiple types of syscalls and other kernel level interactions that applications use through the system libraries.  The syscalls in the example use the BSD interface of syscalls, which begin with 2...  Mac OS X's Kernel is really based on the Mach kernel developed at Carnegie Mellon.  There are a series of Mach based syscalls, known as traps, that the system uses to function.  These begin with 1....

I am in the process of building the system libraries statically.  This has not been an easy task.  Even though Apple has a lot of code that it releases open source, there are a lot of files that are missing.  As far as I can tell, most of these files are innocuous files, header files with function prototypes or simple macros. It necessitates an exhaustive search tracking down these files.  The opacity of a lot of Apple's open source offerings makes it impossible to get a clear sense of how the library works as a whole.  It is impossible to know whether a missing header file is significant or not.

Static linking executable is usually not practical, but having that option can give a programmer a way to understand how their executable interacts with the system processes.  Everything is present in a single executable.  With OS X's inflexible implementation of dynamic linking, it is hard to get a sense of what is happening under the hood.  
